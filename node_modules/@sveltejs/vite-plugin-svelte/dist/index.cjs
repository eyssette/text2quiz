var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  svelte: () => svelte
});

// ../../node_modules/.pnpm/tsup@5.11.13_typescript@4.5.5/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/index.ts
var import_fs6 = __toESM(require("fs"), 1);

// src/utils/log.ts
var import_colors = require("kleur/colors");
var import_debug = __toESM(require("debug"), 1);
var levels = ["debug", "info", "warn", "error", "silent"];
var prefix = "vite-plugin-svelte";
var loggers = {
  debug: {
    log: (0, import_debug.default)(`vite:${prefix}`),
    enabled: false,
    isDebug: true
  },
  info: {
    color: import_colors.cyan,
    log: console.log,
    enabled: true
  },
  warn: {
    color: import_colors.yellow,
    log: console.warn,
    enabled: true
  },
  error: {
    color: import_colors.red,
    log: console.error,
    enabled: true
  },
  silent: {
    enabled: false
  }
};
var _level = "info";
function setLevel(level) {
  if (level === _level) {
    return;
  }
  const levelIndex = levels.indexOf(level);
  if (levelIndex > -1) {
    _level = level;
    for (let i = 0; i < levels.length; i++) {
      loggers[levels[i]].enabled = i >= levelIndex;
    }
  } else {
    _log(loggers.error, `invalid log level: ${level} `);
  }
}
function _log(logger, message, payload) {
  if (!logger.enabled) {
    return;
  }
  if (logger.isDebug) {
    payload !== void 0 ? logger.log(message, payload) : logger.log(message);
  } else {
    logger.log(logger.color(`${new Date().toLocaleTimeString()} [${prefix}] ${message}`));
    if (payload) {
      logger.log(payload);
    }
  }
}
function createLogger(level) {
  const logger = loggers[level];
  const logFn = _log.bind(null, logger);
  const logged = /* @__PURE__ */ new Set();
  const once = function(message, payload) {
    if (logged.has(message)) {
      return;
    }
    logged.add(message);
    logFn.apply(null, [message, payload]);
  };
  Object.defineProperty(logFn, "enabled", {
    get() {
      return logger.enabled;
    }
  });
  Object.defineProperty(logFn, "once", {
    get() {
      return once;
    }
  });
  return logFn;
}
var log = {
  debug: createLogger("debug"),
  info: createLogger("info"),
  warn: createLogger("warn"),
  error: createLogger("error"),
  setLevel
};
function logCompilerWarnings(warnings, options) {
  const { emitCss, onwarn, isBuild } = options;
  const warn = isBuild ? warnBuild : warnDev;
  const notIgnoredWarnings = warnings == null ? void 0 : warnings.filter((w) => !ignoreCompilerWarning(w, isBuild, emitCss));
  const extraWarnings = buildExtraWarnings(warnings, isBuild);
  [...notIgnoredWarnings, ...extraWarnings].forEach((warning) => {
    if (onwarn) {
      onwarn(warning, warn);
    } else {
      warn(warning);
    }
  });
}
function ignoreCompilerWarning(warning, isBuild, emitCss) {
  return !emitCss && warning.code === "css-unused-selector" || !isBuild && isNoScopableElementWarning(warning);
}
function isNoScopableElementWarning(warning) {
  return warning.code === "css-unused-selector" && warning.message.includes('"*"');
}
function buildExtraWarnings(warnings, isBuild) {
  const extraWarnings = [];
  if (!isBuild) {
    const noScopableElementWarnings = warnings.filter((w) => isNoScopableElementWarning(w));
    if (noScopableElementWarnings.length > 0) {
      const noScopableElementWarning = noScopableElementWarnings[noScopableElementWarnings.length - 1];
      extraWarnings.push(__spreadProps(__spreadValues({}, noScopableElementWarning), {
        code: "vite-plugin-svelte-css-no-scopable-elements",
        message: `No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles.`
      }));
    }
  }
  return extraWarnings;
}
function warnDev(w) {
  log.info.enabled && log.info(buildExtendedLogMessage(w));
}
function warnBuild(w) {
  log.warn.enabled && log.warn(buildExtendedLogMessage(w), w.frame);
}
function buildExtendedLogMessage(w) {
  const parts = [];
  if (w.filename) {
    parts.push(w.filename);
  }
  if (w.start) {
    parts.push(":", w.start.line, ":", w.start.column);
  }
  if (w.message) {
    if (parts.length > 0) {
      parts.push(" ");
    }
    parts.push(w.message);
  }
  return parts.join("");
}

// src/handle-hot-update.ts
async function handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options) {
  const { read, server } = ctx;
  const cachedJS = cache.getJS(svelteRequest);
  if (!cachedJS) {
    log.debug(`handleHotUpdate first call ${svelteRequest.id}`);
    return;
  }
  const cachedCss = cache.getCSS(svelteRequest);
  const content = await read();
  const compileData = await compileSvelte2(svelteRequest, content, options);
  cache.update(compileData);
  const affectedModules = /* @__PURE__ */ new Set();
  const cssModule = server.moduleGraph.getModuleById(svelteRequest.cssId);
  const mainModule = server.moduleGraph.getModuleById(svelteRequest.id);
  const cssUpdated = cssModule && cssChanged(cachedCss, compileData.compiled.css);
  if (cssUpdated) {
    log.debug("handleHotUpdate css changed");
    affectedModules.add(cssModule);
  }
  const jsUpdated = mainModule && jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);
  if (jsUpdated) {
    log.debug("handleHotUpdate js changed");
    affectedModules.add(mainModule);
  }
  if (!jsUpdated) {
    logCompilerWarnings(compileData.compiled.warnings, options);
  }
  const result = [...affectedModules].filter(Boolean);
  const ssrModulesToInvalidate = result.filter((m) => !!m.ssrTransformResult);
  if (ssrModulesToInvalidate.length > 0) {
    log.debug(`invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(", ")}`);
    ssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));
  }
  if (result.length > 0) {
    log.debug(`handleHotUpdate for ${svelteRequest.id} result: ${result.map((m) => m.id).join(", ")}`);
  }
  return result;
}
function cssChanged(prev, next) {
  return !isCodeEqual(prev == null ? void 0 : prev.code, next == null ? void 0 : next.code);
}
function jsChanged(prev, next, filename) {
  const prevJs = prev == null ? void 0 : prev.code;
  const nextJs = next == null ? void 0 : next.code;
  const isStrictEqual = isCodeEqual(prevJs, nextJs);
  if (isStrictEqual) {
    return false;
  }
  const isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));
  if (!isStrictEqual && isLooseEqual) {
    log.warn(`ignoring compiler output js change for ${filename} as it is equal to previous output after normalization`);
  }
  return !isLooseEqual;
}
function isCodeEqual(prev, next) {
  if (!prev && !next) {
    return true;
  }
  if (!prev && next || prev && !next) {
    return false;
  }
  return prev === next;
}
function normalizeJsCode(code) {
  if (!code) {
    return code;
  }
  return code.replace(/\s*\badd_location\s*\([^)]*\)\s*;?/g, "");
}

// src/utils/compile.ts
var import_compiler = require("svelte/compiler");
var import_svelte_hmr = require("svelte-hmr");

// src/utils/hash.ts
var crypto = __toESM(require("crypto"), 1);
var hashes = /* @__PURE__ */ Object.create(null);
var hash_length = 12;
function safeBase64Hash(input) {
  if (hashes[input]) {
    return hashes[input];
  }
  const md5 = crypto.createHash("md5");
  md5.update(input);
  const hash = toSafe(md5.digest("base64")).substr(0, hash_length);
  hashes[input] = hash;
  return hash;
}
var replacements = {
  "+": "-",
  "/": "_",
  "=": ""
};
var replaceRE = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function toSafe(base64) {
  return base64.replace(replaceRE, (x) => replacements[x]);
}

// src/utils/compile.ts
var _createCompileSvelte = (makeHot) => async function compileSvelte2(svelteRequest, code, options) {
  var _a, _b;
  const { filename, normalizedFilename, cssId, ssr } = svelteRequest;
  const { emitCss = true } = options;
  const dependencies = [];
  const compileOptions = __spreadProps(__spreadValues({}, options.compilerOptions), {
    filename,
    generate: ssr ? "ssr" : "dom"
  });
  if (options.hot && options.emitCss) {
    const hash = `s-${safeBase64Hash(normalizedFilename)}`;
    log.debug(`setting cssHash ${hash} for ${normalizedFilename}`);
    compileOptions.cssHash = () => hash;
  }
  if (ssr && compileOptions.enableSourcemap !== false) {
    if (typeof compileOptions.enableSourcemap === "object") {
      compileOptions.enableSourcemap.css = false;
    } else {
      compileOptions.enableSourcemap = { js: true, css: false };
    }
  }
  let preprocessed;
  if (options.preprocess) {
    try {
      preprocessed = await (0, import_compiler.preprocess)(code, options.preprocess, { filename });
    } catch (e) {
      e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ""}`;
      throw e;
    }
    if (preprocessed.dependencies)
      dependencies.push(...preprocessed.dependencies);
    if (preprocessed.map)
      compileOptions.sourcemap = preprocessed.map;
  }
  const finalCode = preprocessed ? preprocessed.code : code;
  const dynamicCompileOptions = await ((_b = (_a = options.experimental) == null ? void 0 : _a.dynamicCompileOptions) == null ? void 0 : _b.call(_a, {
    filename,
    code: finalCode,
    compileOptions
  }));
  if (dynamicCompileOptions && log.debug.enabled) {
    log.debug(`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`);
  }
  const finalCompileOptions = dynamicCompileOptions ? __spreadValues(__spreadValues({}, compileOptions), dynamicCompileOptions) : compileOptions;
  const compiled = (0, import_compiler.compile)(finalCode, finalCompileOptions);
  if (emitCss && compiled.css.code) {
    compiled.js.code += `
import ${JSON.stringify(cssId)};
`;
  }
  if (!ssr && makeHot) {
    compiled.js.code = makeHot({
      id: filename,
      compiledCode: compiled.js.code,
      hotOptions: options.hot,
      compiled,
      originalCode: code,
      compileOptions: finalCompileOptions
    });
  }
  compiled.js.dependencies = dependencies;
  return {
    filename,
    normalizedFilename,
    compiled,
    ssr,
    dependencies
  };
};
function buildMakeHot(options) {
  var _a, _b;
  const needsMakeHot = options.hot !== false && options.isServe && !options.isProduction;
  if (needsMakeHot) {
    const hotApi = (_a = options == null ? void 0 : options.hot) == null ? void 0 : _a.hotApi;
    const adapter = (_b = options == null ? void 0 : options.hot) == null ? void 0 : _b.adapter;
    return (0, import_svelte_hmr.createMakeHot)({
      walk: import_compiler.walk,
      hotApi,
      adapter,
      hotOptions: __spreadValues({ noOverlay: true }, options.hot)
    });
  }
}
function createCompileSvelte(options) {
  const makeHot = buildMakeHot(options);
  return _createCompileSvelte(makeHot);
}

// src/utils/id.ts
var import_pluginutils = require("@rollup/pluginutils");
var import_vite = require("vite");
var fs = __toESM(require("fs"), 1);
var VITE_FS_PREFIX = "/@fs/";
var IS_WINDOWS = process.platform === "win32";
function splitId(id) {
  const parts = id.split(`?`, 2);
  const filename = parts[0];
  const rawQuery = parts[1];
  return { filename, rawQuery };
}
function parseToSvelteRequest(id, filename, rawQuery, root, timestamp, ssr) {
  const query = parseRequestQuery(rawQuery);
  if (query.url || query.raw) {
    return;
  }
  const normalizedFilename = normalize(filename, root);
  const cssId = createVirtualImportId(filename, root, "style");
  return {
    id,
    filename,
    normalizedFilename,
    cssId,
    query,
    timestamp,
    ssr
  };
}
function createVirtualImportId(filename, root, type) {
  const parts = ["svelte", `type=${type}`];
  if (type === "style") {
    parts.push("lang.css");
  }
  if (existsInRoot(filename, root)) {
    filename = root + filename;
  } else if (filename.startsWith(VITE_FS_PREFIX)) {
    filename = IS_WINDOWS ? filename.slice(VITE_FS_PREFIX.length) : filename.slice(VITE_FS_PREFIX.length - 1);
  }
  return `${filename}?${parts.join("&")}`;
}
function parseRequestQuery(rawQuery) {
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  for (const key in query) {
    if (query[key] === "") {
      query[key] = true;
    }
  }
  return query;
}
function normalize(filename, normalizedRoot) {
  return stripRoot((0, import_vite.normalizePath)(filename), normalizedRoot);
}
function existsInRoot(filename, root) {
  if (filename.startsWith(VITE_FS_PREFIX)) {
    return false;
  }
  return fs.existsSync(root + filename);
}
function stripRoot(normalizedFilename, normalizedRoot) {
  return normalizedFilename.startsWith(normalizedRoot + "/") ? normalizedFilename.slice(normalizedRoot.length) : normalizedFilename;
}
function buildFilter(include, exclude, extensions) {
  const rollupFilter = (0, import_pluginutils.createFilter)(include, exclude);
  return (filename) => rollupFilter(filename) && extensions.some((ext) => filename.endsWith(ext));
}
function buildIdParser(options) {
  const { include, exclude, extensions, root } = options;
  const normalizedRoot = (0, import_vite.normalizePath)(root);
  const filter = buildFilter(include, exclude, extensions);
  return (id, ssr, timestamp = Date.now()) => {
    const { filename, rawQuery } = splitId(id);
    if (filter(filename)) {
      return parseToSvelteRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);
    }
  };
}

// src/utils/options.ts
var import_vite3 = require("vite");

// src/utils/load-svelte-config.ts
var import_module = require("module");
var import_path = __toESM(require("path"), 1);
var import_fs = __toESM(require("fs"), 1);
var import_url = require("url");
var esmRequire;
var knownSvelteConfigNames = [
  "svelte.config.js",
  "svelte.config.cjs",
  "svelte.config.mjs"
];
var dynamicImportDefault = new Function("path", 'return import(path + "?t=" + Date.now()).then(m => m.default)');
async function loadSvelteConfig(viteConfig, inlineOptions) {
  const configFile = findConfigToLoad(viteConfig, inlineOptions);
  if (configFile) {
    let err;
    if (configFile.endsWith(".js") || configFile.endsWith(".mjs")) {
      try {
        const result = await dynamicImportDefault((0, import_url.pathToFileURL)(configFile).href);
        if (result != null) {
          return __spreadProps(__spreadValues({}, result), {
            configFile
          });
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e) {
        log.error(`failed to import config ${configFile}`, e);
        err = e;
      }
    }
    if (!configFile.endsWith(".mjs")) {
      try {
        const _require = importMetaUrl ? esmRequire ?? (esmRequire = (0, import_module.createRequire)(importMetaUrl)) : require;
        delete _require.cache[_require.resolve(configFile)];
        const result = _require(configFile);
        if (result != null) {
          return __spreadProps(__spreadValues({}, result), {
            configFile
          });
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e) {
        log.error(`failed to require config ${configFile}`, e);
        if (!err) {
          err = e;
        }
      }
    }
    throw err;
  }
}
function findConfigToLoad(viteConfig, inlineOptions) {
  const root = viteConfig.root || process.cwd();
  if (inlineOptions.configFile) {
    const abolutePath = import_path.default.isAbsolute(inlineOptions.configFile) ? inlineOptions.configFile : import_path.default.resolve(root, inlineOptions.configFile);
    if (!import_fs.default.existsSync(abolutePath)) {
      throw new Error(`failed to find svelte config file ${abolutePath}.`);
    }
    return abolutePath;
  } else {
    const existingKnownConfigFiles = knownSvelteConfigNames.map((candidate) => import_path.default.resolve(root, candidate)).filter((file) => import_fs.default.existsSync(file));
    if (existingKnownConfigFiles.length === 0) {
      log.debug(`no svelte config found at ${root}`);
      return;
    } else if (existingKnownConfigFiles.length > 1) {
      log.warn(`found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`, existingKnownConfigFiles);
    }
    return existingKnownConfigFiles[0];
  }
}

// src/utils/constants.ts
var VITE_RESOLVE_MAIN_FIELDS = ["module", "jsnext:main", "jsnext"];
var SVELTE_RESOLVE_MAIN_FIELDS = ["svelte", ...VITE_RESOLVE_MAIN_FIELDS];
var SVELTE_IMPORTS = [
  "svelte/animate",
  "svelte/easing",
  "svelte/internal",
  "svelte/motion",
  "svelte/ssr",
  "svelte/store",
  "svelte/transition",
  "svelte"
];
var SVELTE_HMR_IMPORTS = [
  "svelte-hmr/runtime/hot-api-esm.js",
  "svelte-hmr/runtime/proxy-adapter-dom.js",
  "svelte-hmr"
];

// src/utils/options.ts
var import_path3 = __toESM(require("path"), 1);

// src/utils/dependencies.ts
var import_path2 = __toESM(require("path"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_module2 = require("module");
function findRootSvelteDependencies(root, cwdFallback = true) {
  log.debug(`findSvelteDependencies: searching svelte dependencies in ${root}`);
  const pkgFile = import_path2.default.join(root, "package.json");
  if (!import_fs2.default.existsSync(pkgFile)) {
    if (cwdFallback) {
      const cwd = process.cwd();
      if (root !== cwd) {
        log.debug(`no package.json found in vite root ${root}`);
        return findRootSvelteDependencies(cwd, false);
      }
    }
    log.warn(`no package.json found, findRootSvelteDependencies failed`);
    return [];
  }
  const pkg = parsePkg(root);
  if (!pkg) {
    return [];
  }
  const deps = [
    ...Object.keys(pkg.dependencies || {}),
    ...Object.keys(pkg.devDependencies || {})
  ].filter((dep) => !is_common_without_svelte_field(dep));
  return getSvelteDependencies(deps, root);
}
function getSvelteDependencies(deps, pkgDir, path7 = []) {
  const result = [];
  const localRequire = (0, import_module2.createRequire)(`${pkgDir}/package.json`);
  const resolvedDeps = deps.map((dep) => resolveDependencyData(dep, localRequire)).filter(Boolean);
  for (const { pkg, dir } of resolvedDeps) {
    const type = getSvelteDependencyType(pkg);
    if (!type)
      continue;
    result.push({ name: pkg.name, type, pkg, dir, path: path7 });
    if (type === "component-library" && pkg.dependencies) {
      let dependencyNames = Object.keys(pkg.dependencies);
      const circular = dependencyNames.filter((name) => path7.includes(name));
      if (circular.length > 0) {
        log.warn.enabled && log.warn(`skipping circular svelte dependencies in automated vite optimizeDeps handling`, circular.map((x) => path7.concat(x).join(">")));
        dependencyNames = dependencyNames.filter((name) => !path7.includes(name));
      }
      if (path7.length === 3) {
        log.debug.once(`encountered deep svelte dependency tree: ${path7.join(">")}`);
      }
      result.push(...getSvelteDependencies(dependencyNames, dir, path7.concat(pkg.name)));
    }
  }
  return result;
}
function resolveDependencyData(dep, localRequire) {
  try {
    const pkgJson = `${dep}/package.json`;
    const pkg = localRequire(pkgJson);
    const dir = import_path2.default.dirname(localRequire.resolve(pkgJson));
    return { dir, pkg };
  } catch (e) {
    log.debug.once(`dependency ${dep} does not export package.json`, e);
    try {
      let dir = import_path2.default.dirname(localRequire.resolve(dep));
      while (dir) {
        const pkg = parsePkg(dir, true);
        if (pkg && pkg.name === dep) {
          return { dir, pkg };
        }
        const parent = import_path2.default.dirname(dir);
        if (parent === dir) {
          break;
        }
        dir = parent;
      }
    } catch (e2) {
      log.debug.once(`error while trying to find package.json of ${dep}`, e2);
    }
  }
  log.debug.once(`failed to resolve ${dep}`);
}
function parsePkg(dir, silent = false) {
  const pkgFile = import_path2.default.join(dir, "package.json");
  try {
    return JSON.parse(import_fs2.default.readFileSync(pkgFile, "utf-8"));
  } catch (e) {
    !silent && log.warn.enabled && log.warn(`failed to parse ${pkgFile}`, e);
  }
}
function getSvelteDependencyType(pkg) {
  if (isSvelteComponentLib(pkg)) {
    return "component-library";
  } else if (isSvelteLib(pkg)) {
    return "js-library";
  } else {
    return void 0;
  }
}
function isSvelteComponentLib(pkg) {
  return !!pkg.svelte;
}
function isSvelteLib(pkg) {
  var _a, _b;
  return !!((_a = pkg.dependencies) == null ? void 0 : _a.svelte) || !!((_b = pkg.peerDependencies) == null ? void 0 : _b.svelte);
}
var COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [
  "@lukeed/uuid",
  "@sveltejs/vite-plugin-svelte",
  "@sveltejs/kit",
  "autoprefixer",
  "cookie",
  "dotenv",
  "esbuild",
  "eslint",
  "jest",
  "mdsvex",
  "postcss",
  "prettier",
  "svelte",
  "svelte-check",
  "svelte-hmr",
  "svelte-preprocess",
  "tslib",
  "typescript",
  "vite"
];
var COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [
  "@fontsource/",
  "@postcss-plugins/",
  "@rollup/",
  "@sveltejs/adapter-",
  "@types/",
  "@typescript-eslint/",
  "eslint-",
  "jest-",
  "postcss-plugin-",
  "prettier-plugin-",
  "rollup-plugin-",
  "vite-plugin-"
];
function is_common_without_svelte_field(dependency) {
  return COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) || COMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some((prefix2) => prefix2.startsWith("@") ? dependency.startsWith(prefix2) : dependency.substring(dependency.lastIndexOf("/") + 1).startsWith(prefix2));
}
function needsOptimization(dep, localRequire) {
  const depData = resolveDependencyData(dep, localRequire);
  if (!depData)
    return false;
  const pkg = depData.pkg;
  const isCjs = pkg.main && !pkg.module && !pkg.exports;
  if (!isCjs)
    return false;
  const entryExt = import_path2.default.extname(pkg.main);
  return !entryExt || entryExt === ".js" || entryExt === ".cjs";
}

// src/utils/options.ts
var import_module3 = require("module");

// src/utils/esbuild.ts
var import_fs3 = require("fs");
var import_compiler2 = require("svelte/compiler");

// src/utils/error.ts
function toRollupError(error, options) {
  const { filename, frame, start, code, name, stack } = error;
  const rollupError = {
    name,
    id: filename,
    message: buildExtendedLogMessage(error),
    frame: formatFrameForVite(frame),
    code,
    stack: options.isBuild || options.isDebug || !frame ? stack : ""
  };
  if (start) {
    rollupError.loc = {
      line: start.line,
      column: start.column,
      file: filename
    };
  }
  return rollupError;
}
function toESBuildError(error, options) {
  const { filename, frame, start, stack } = error;
  const partialMessage = {
    text: buildExtendedLogMessage(error)
  };
  if (start) {
    partialMessage.location = {
      line: start.line,
      column: start.column,
      file: filename,
      lineText: lineFromFrame(start.line, frame)
    };
  }
  if (options.isBuild || options.isDebug || !frame) {
    partialMessage.detail = stack;
  }
  return partialMessage;
}
function lineFromFrame(lineNo, frame) {
  if (!frame) {
    return "";
  }
  const lines = frame.split("\n");
  const errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));
  return errorLine ? errorLine.substring(errorLine.indexOf(": ") + 3) : "";
}
function formatFrameForVite(frame) {
  if (!frame) {
    return "";
  }
  return frame.split("\n").map((line) => line.match(/^\s+\^/) ? "   " + line : " " + line.replace(":", " | ")).join("\n");
}

// src/utils/esbuild.ts
var facadeEsbuildSveltePluginName = "vite-plugin-svelte:facade";
function esbuildSveltePlugin(options) {
  return {
    name: "vite-plugin-svelte:optimize-svelte",
    setup(build) {
      disableVitePrebundleSvelte(build);
      const svelteExtensions = (options.extensions ?? [".svelte"]).map((ext) => ext.slice(1));
      const svelteFilter = new RegExp(`\\.(` + svelteExtensions.join("|") + `)(\\?.*)?$`);
      build.onLoad({ filter: svelteFilter }, async ({ path: filename }) => {
        const code = await import_fs3.promises.readFile(filename, "utf8");
        try {
          const contents = await compileSvelte(options, { filename, code });
          return { contents };
        } catch (e) {
          return { errors: [toESBuildError(e, options)] };
        }
      });
    }
  };
}
function disableVitePrebundleSvelte(build) {
  var _a;
  const viteDepPrebundlePlugin = (_a = build.initialOptions.plugins) == null ? void 0 : _a.find((v) => v.name === "vite:dep-pre-bundle");
  if (!viteDepPrebundlePlugin)
    return;
  const _setup = viteDepPrebundlePlugin.setup.bind(viteDepPrebundlePlugin);
  viteDepPrebundlePlugin.setup = function(build2) {
    const _onResolve = build2.onResolve.bind(build2);
    build2.onResolve = function(options, callback) {
      if (options.filter.source.includes("svelte")) {
        options.filter = new RegExp(options.filter.source.replace("|svelte", ""), options.filter.flags);
      }
      return _onResolve(options, callback);
    };
    return _setup(build2);
  };
}
async function compileSvelte(options, { filename, code }) {
  var _a, _b;
  const compileOptions = __spreadProps(__spreadValues({}, options.compilerOptions), {
    css: true,
    filename,
    format: "esm",
    generate: "dom"
  });
  let preprocessed;
  if (options.preprocess) {
    try {
      preprocessed = await (0, import_compiler2.preprocess)(code, options.preprocess, { filename });
    } catch (e) {
      e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ""}`;
      throw e;
    }
    if (preprocessed.map)
      compileOptions.sourcemap = preprocessed.map;
  }
  const finalCode = preprocessed ? preprocessed.code : code;
  const dynamicCompileOptions = await ((_b = (_a = options.experimental) == null ? void 0 : _a.dynamicCompileOptions) == null ? void 0 : _b.call(_a, {
    filename,
    code: finalCode,
    compileOptions
  }));
  if (dynamicCompileOptions && log.debug.enabled) {
    log.debug(`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`);
  }
  const finalCompileOptions = dynamicCompileOptions ? __spreadValues(__spreadValues({}, compileOptions), dynamicCompileOptions) : compileOptions;
  const compiled = (0, import_compiler2.compile)(finalCode, finalCompileOptions);
  return compiled.js.code + "//# sourceMappingURL=" + compiled.js.map.toUrl();
}

// src/utils/preprocess.ts
var import_vite2 = require("vite");
var import_magic_string2 = __toESM(require("magic-string"), 1);
var import_compiler3 = require("svelte/compiler");

// src/utils/sourcemap.ts
var import_magic_string = __toESM(require("magic-string"), 1);
async function buildMagicString(from, to, options) {
  let diff_match_patch, DIFF_DELETE, DIFF_INSERT;
  try {
    const dmpPkg = await import("diff-match-patch");
    diff_match_patch = dmpPkg.diff_match_patch;
    DIFF_INSERT = dmpPkg.DIFF_INSERT;
    DIFF_DELETE = dmpPkg.DIFF_DELETE;
  } catch (e) {
    log.error.once('Failed to import optional dependency "diff-match-patch". Please install it to enable generated sourcemaps.');
    return null;
  }
  const dmp = new diff_match_patch();
  const diffs = dmp.diff_main(from, to);
  dmp.diff_cleanupSemantic(diffs);
  const m = new import_magic_string.default(from, options);
  let pos = 0;
  for (let i = 0; i < diffs.length; i++) {
    const diff = diffs[i];
    const nextDiff = diffs[i + 1];
    if (diff[0] === DIFF_DELETE) {
      if ((nextDiff == null ? void 0 : nextDiff[0]) === DIFF_INSERT) {
        m.overwrite(pos, pos + diff[1].length, nextDiff[1]);
        i++;
      } else {
        m.remove(pos, pos + diff[1].length);
      }
      pos += diff[1].length;
    } else if (diff[0] === DIFF_INSERT) {
      if (nextDiff) {
        m.appendRight(pos, diff[1]);
      } else {
        m.append(diff[1]);
      }
    } else {
      pos += diff[1].length;
    }
  }
  return m;
}
async function buildSourceMap(from, to, filename) {
  const m = await buildMagicString(from, to, { filename });
  return m ? m.generateDecodedMap({ source: filename, hires: true, includeContent: false }) : null;
}

// src/utils/preprocess.ts
var supportedStyleLangs = ["css", "less", "sass", "scss", "styl", "stylus", "postcss"];
var supportedScriptLangs = ["ts"];
function createViteScriptPreprocessor() {
  return async ({ attributes, content, filename = "" }) => {
    const lang = attributes.lang;
    if (!supportedScriptLangs.includes(lang))
      return;
    const transformResult = await (0, import_vite2.transformWithEsbuild)(content, filename, {
      loader: lang,
      tsconfigRaw: {
        compilerOptions: {
          importsNotUsedAsValues: "preserve",
          preserveValueImports: true
        }
      }
    });
    return {
      code: transformResult.code,
      map: transformResult.map
    };
  };
}
function createViteStylePreprocessor(config) {
  const pluginName = "vite:css";
  const plugin = config.plugins.find((p) => p.name === pluginName);
  if (!plugin) {
    throw new Error(`failed to find plugin ${pluginName}`);
  }
  if (!plugin.transform) {
    throw new Error(`plugin ${pluginName} has no transform`);
  }
  const pluginTransform = plugin.transform.bind(null);
  return async ({ attributes, content, filename = "" }) => {
    var _a, _b;
    const lang = attributes.lang;
    if (!supportedStyleLangs.includes(lang))
      return;
    const moduleId = `${filename}.${lang}`;
    const transformResult = await pluginTransform(content, moduleId);
    if (((_b = (_a = transformResult.map) == null ? void 0 : _a.sources) == null ? void 0 : _b[0]) === moduleId) {
      transformResult.map.sources[0] = filename;
    }
    return {
      code: transformResult.code,
      map: transformResult.map ?? void 0
    };
  };
}
function createVitePreprocessorGroup(config) {
  return {
    markup({ content, filename }) {
      return (0, import_compiler3.preprocess)(content, {
        script: createViteScriptPreprocessor(),
        style: createViteStylePreprocessor(config)
      }, { filename });
    }
  };
}
function createInjectScopeEverythingRulePreprocessorGroup() {
  return {
    style({ content, filename }) {
      const s = new import_magic_string2.default(content);
      s.append(" *{}");
      return {
        code: s.toString(),
        map: s.generateDecodedMap({ source: filename, hires: true })
      };
    }
  };
}
function buildExtraPreprocessors(options, config) {
  var _a, _b;
  const prependPreprocessors = [];
  const appendPreprocessors = [];
  if ((_a = options.experimental) == null ? void 0 : _a.useVitePreprocess) {
    log.debug("adding vite preprocessor");
    prependPreprocessors.push(createVitePreprocessorGroup(config));
  }
  const pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p == null ? void 0 : p.sveltePreprocess);
  if (pluginsWithPreprocessorsDeprecated.length > 0) {
    log.warn(`The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated.map((p) => p.name).join(", ")}`);
    pluginsWithPreprocessorsDeprecated.forEach((p) => {
      if (!p.api) {
        p.api = {};
      }
      if (p.api.sveltePreprocess === void 0) {
        p.api.sveltePreprocess = p.sveltePreprocess;
      } else {
        log.error(`ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`);
      }
    });
  }
  const pluginsWithPreprocessors = config.plugins.filter((p) => {
    var _a2;
    return (_a2 = p == null ? void 0 : p.api) == null ? void 0 : _a2.sveltePreprocess;
  });
  const ignored = [], included = [];
  for (const p of pluginsWithPreprocessors) {
    if (options.ignorePluginPreprocessors === true || Array.isArray(options.ignorePluginPreprocessors) && ((_b = options.ignorePluginPreprocessors) == null ? void 0 : _b.includes(p.name))) {
      ignored.push(p);
    } else {
      included.push(p);
    }
  }
  if (ignored.length > 0) {
    log.debug(`Ignoring svelte preprocessors defined by these vite plugins: ${ignored.map((p) => p.name).join(", ")}`);
  }
  if (included.length > 0) {
    log.debug(`Adding svelte preprocessors defined by these vite plugins: ${included.map((p) => p.name).join(", ")}`);
    appendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));
  }
  if (options.hot && options.emitCss) {
    appendPreprocessors.push(createInjectScopeEverythingRulePreprocessorGroup());
  }
  return { prependPreprocessors, appendPreprocessors };
}
function addExtraPreprocessors(options, config) {
  var _a;
  const { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);
  if (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {
    if (!options.preprocess) {
      options.preprocess = [...prependPreprocessors, ...appendPreprocessors];
    } else if (Array.isArray(options.preprocess)) {
      options.preprocess.unshift(...prependPreprocessors);
      options.preprocess.push(...appendPreprocessors);
    } else {
      options.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];
    }
  }
  const generateMissingSourceMaps = !!((_a = options.experimental) == null ? void 0 : _a.generateMissingPreprocessorSourcemaps);
  if (options.preprocess && generateMissingSourceMaps) {
    options.preprocess = Array.isArray(options.preprocess) ? options.preprocess.map((p, i) => validateSourceMapOutputWrapper(p, i)) : validateSourceMapOutputWrapper(options.preprocess, 0);
  }
}
function validateSourceMapOutputWrapper(group, i) {
  const wrapper = {};
  for (const [processorType, processorFn] of Object.entries(group)) {
    wrapper[processorType] = async (options) => {
      var _a;
      const result = await processorFn(options);
      if (result && result.code !== options.content) {
        let invalidMap = false;
        if (!result.map) {
          invalidMap = true;
          log.warn.enabled && log.warn.once(`preprocessor at index ${i} did not return a sourcemap for ${processorType} transform`, {
            filename: options.filename,
            type: processorType,
            processor: processorFn.toString()
          });
        } else if (((_a = result.map) == null ? void 0 : _a.mappings) === "") {
          invalidMap = true;
          log.warn.enabled && log.warn.once(`preprocessor at index ${i} returned an invalid empty sourcemap for ${processorType} transform`, {
            filename: options.filename,
            type: processorType,
            processor: processorFn.toString()
          });
        }
        if (invalidMap) {
          try {
            const map = await buildSourceMap(options.content, result.code, options.filename);
            if (map) {
              log.debug.enabled && log.debug(`adding generated sourcemap to preprocesor result for ${options.filename}`);
              result.map = map;
            }
          } catch (e) {
            log.error(`failed to build sourcemap`, e);
          }
        }
      }
      return result;
    };
  }
  return wrapper;
}

// src/utils/options.ts
var knownOptions = /* @__PURE__ */ new Set([
  "configFile",
  "include",
  "exclude",
  "extensions",
  "emitCss",
  "compilerOptions",
  "onwarn",
  "preprocess",
  "hot",
  "ignorePluginPreprocessors",
  "disableDependencyReinclusion",
  "experimental"
]);
function validateInlineOptions(inlineOptions) {
  const invalidKeys = Object.keys(inlineOptions || {}).filter((key) => !knownOptions.has(key));
  if (invalidKeys.length) {
    log.warn(`invalid plugin options "${invalidKeys.join(", ")}" in config`, inlineOptions);
  }
}
async function preResolveOptions(inlineOptions = {}, viteUserConfig, viteEnv) {
  const viteConfigWithResolvedRoot = __spreadProps(__spreadValues({}, viteUserConfig), {
    root: resolveViteRoot(viteUserConfig)
  });
  const defaultOptions = {
    extensions: [".svelte"],
    emitCss: true,
    compilerOptions: {
      format: "esm"
    }
  };
  const svelteConfig = await loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions);
  const merged = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, defaultOptions), svelteConfig), inlineOptions), {
    compilerOptions: __spreadValues(__spreadValues(__spreadValues({}, defaultOptions == null ? void 0 : defaultOptions.compilerOptions), svelteConfig == null ? void 0 : svelteConfig.compilerOptions), inlineOptions == null ? void 0 : inlineOptions.compilerOptions),
    experimental: __spreadValues(__spreadValues(__spreadValues({}, defaultOptions == null ? void 0 : defaultOptions.experimental), svelteConfig == null ? void 0 : svelteConfig.experimental), inlineOptions == null ? void 0 : inlineOptions.experimental),
    root: viteConfigWithResolvedRoot.root,
    isBuild: viteEnv.command === "build",
    isServe: viteEnv.command === "serve",
    isDebug: process.env.DEBUG != null
  });
  if (svelteConfig == null ? void 0 : svelteConfig.configFile) {
    merged.configFile = svelteConfig.configFile;
  }
  return merged;
}
function resolveOptions(preResolveOptions2, viteConfig) {
  const defaultOptions = {
    hot: viteConfig.isProduction ? false : { injectCss: !preResolveOptions2.emitCss },
    compilerOptions: {
      css: !preResolveOptions2.emitCss,
      dev: !viteConfig.isProduction
    }
  };
  const merged = __spreadProps(__spreadValues(__spreadValues({}, defaultOptions), preResolveOptions2), {
    compilerOptions: __spreadValues(__spreadValues({}, defaultOptions.compilerOptions), preResolveOptions2.compilerOptions),
    root: viteConfig.root,
    isProduction: viteConfig.isProduction
  });
  addExtraPreprocessors(merged, viteConfig);
  enforceOptionsForHmr(merged);
  enforceOptionsForProduction(merged);
  return merged;
}
function enforceOptionsForHmr(options) {
  if (options.hot) {
    if (!options.compilerOptions.dev) {
      log.warn("hmr is enabled but compilerOptions.dev is false, forcing it to true");
      options.compilerOptions.dev = true;
    }
    if (options.emitCss) {
      if (options.hot !== true && options.hot.injectCss) {
        log.warn("hmr and emitCss are enabled but hot.injectCss is true, forcing it to false");
        options.hot.injectCss = false;
      }
      if (options.compilerOptions.css) {
        log.warn("hmr and emitCss are enabled but compilerOptions.css is true, forcing it to false");
        options.compilerOptions.css = false;
      }
    } else {
      if (options.hot === true || !options.hot.injectCss) {
        log.warn("hmr with emitCss disabled requires option hot.injectCss to be enabled, forcing it to true");
        if (options.hot === true) {
          options.hot = { injectCss: true };
        } else {
          options.hot.injectCss = true;
        }
      }
      if (!options.compilerOptions.css) {
        log.warn("hmr with emitCss disabled requires compilerOptions.css to be enabled, forcing it to true");
        options.compilerOptions.css = true;
      }
    }
  }
}
function enforceOptionsForProduction(options) {
  if (options.isProduction) {
    if (options.hot) {
      log.warn("options.hot is enabled but does not work on production build, forcing it to false");
      options.hot = false;
    }
    if (options.compilerOptions.dev) {
      log.warn("you are building for production but compilerOptions.dev is true, forcing it to false");
      options.compilerOptions.dev = false;
    }
  }
}
function resolveViteRoot(viteConfig) {
  return (0, import_vite3.normalizePath)(viteConfig.root ? import_path3.default.resolve(viteConfig.root) : process.cwd());
}
function buildExtraViteConfig(options, config, configEnv) {
  const svelteDeps = findRootSvelteDependencies(options.root);
  const extraViteConfig = {
    resolve: {
      mainFields: [...SVELTE_RESOLVE_MAIN_FIELDS],
      dedupe: [...SVELTE_IMPORTS, ...SVELTE_HMR_IMPORTS]
    }
  };
  if (configEnv.command === "serve") {
    extraViteConfig.optimizeDeps = buildOptimizeDepsForSvelte(svelteDeps, options, config.optimizeDeps);
  }
  extraViteConfig.ssr = buildSSROptionsForSvelte(svelteDeps, options, config);
  return extraViteConfig;
}
function buildOptimizeDepsForSvelte(svelteDeps, options, optimizeDeps2) {
  const include = [];
  const exclude = ["svelte-hmr"];
  const isIncluded = (dep) => {
    var _a;
    return include.includes(dep) || ((_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.include) == null ? void 0 : _a.includes(dep));
  };
  const isExcluded = (dep) => {
    var _a;
    return exclude.includes(dep) || ((_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude) == null ? void 0 : _a.some((id) => dep === id || id.startsWith(`${dep}/`)));
  };
  if (!isExcluded("svelte")) {
    const svelteImportsToInclude = SVELTE_IMPORTS.filter((x) => x !== "svelte/ssr");
    log.debug(`adding bare svelte packages to optimizeDeps.include: ${svelteImportsToInclude.join(", ")} `);
    include.push(...svelteImportsToInclude.filter((x) => !isIncluded(x)));
  } else {
    log.debug('"svelte" is excluded in optimizeDeps.exclude, skipped adding it to include.');
  }
  if (options.experimental.prebundleSvelteLibraries) {
    return {
      include,
      exclude,
      esbuildOptions: {
        plugins: [{ name: facadeEsbuildSveltePluginName, setup: () => {
        } }]
      }
    };
  }
  svelteDeps = svelteDeps.filter((dep) => dep.type === "component-library");
  const svelteDepsToExclude = Array.from(new Set(svelteDeps.map((dep) => dep.name))).filter((dep) => !isIncluded(dep));
  log.debug(`automatically excluding found svelte dependencies: ${svelteDepsToExclude.join(", ")}`);
  exclude.push(...svelteDepsToExclude.filter((x) => !isExcluded(x)));
  if (options.disableDependencyReinclusion !== true) {
    const disabledReinclusions = options.disableDependencyReinclusion || [];
    if (disabledReinclusions.length > 0) {
      log.debug(`not reincluding transitive dependencies of`, disabledReinclusions);
    }
    const transitiveDepsToInclude = svelteDeps.filter((dep) => !disabledReinclusions.includes(dep.name) && isExcluded(dep.name)).flatMap((dep) => {
      const localRequire = (0, import_module3.createRequire)(`${dep.dir}/package.json`);
      return Object.keys(dep.pkg.dependencies || {}).filter((depOfDep) => !isExcluded(depOfDep) && needsOptimization(depOfDep, localRequire)).map((depOfDep) => dep.path.concat(dep.name, depOfDep).join(" > "));
    });
    log.debug(`reincluding transitive dependencies of excluded svelte dependencies`, transitiveDepsToInclude);
    include.push(...transitiveDepsToInclude);
  }
  return { include, exclude };
}
function buildSSROptionsForSvelte(svelteDeps, options, config) {
  var _a, _b, _c;
  const noExternal = [];
  if (options.isBuild && ((_a = config.build) == null ? void 0 : _a.ssr)) {
    if (!((_c = (_b = config.ssr) == null ? void 0 : _b.external) == null ? void 0 : _c.includes("svelte"))) {
      noExternal.push("svelte");
    }
  } else {
    svelteDeps = svelteDeps.filter((dep) => dep.type === "component-library");
  }
  noExternal.push(...Array.from(new Set(svelteDeps.map((s) => s.name))).filter((x) => {
    var _a2, _b2, _c2, _d;
    return !((_b2 = (_a2 = config.ssr) == null ? void 0 : _a2.external) == null ? void 0 : _b2.includes(x)) && !((_d = (_c2 = config.optimizeDeps) == null ? void 0 : _c2.include) == null ? void 0 : _d.includes(x));
  }));
  return {
    noExternal
  };
}
function patchResolvedViteConfig(viteConfig, options) {
  var _a, _b;
  const facadeEsbuildSveltePlugin = (_b = (_a = viteConfig.optimizeDeps.esbuildOptions) == null ? void 0 : _a.plugins) == null ? void 0 : _b.find((plugin) => plugin.name === facadeEsbuildSveltePluginName);
  if (facadeEsbuildSveltePlugin) {
    Object.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));
  }
}

// src/utils/vite-plugin-svelte-cache.ts
var VitePluginSvelteCache = class {
  constructor() {
    this._css = /* @__PURE__ */ new Map();
    this._js = /* @__PURE__ */ new Map();
    this._dependencies = /* @__PURE__ */ new Map();
    this._dependants = /* @__PURE__ */ new Map();
    this._resolvedSvelteFields = /* @__PURE__ */ new Map();
  }
  update(compileData) {
    this.updateCSS(compileData);
    this.updateJS(compileData);
    this.updateDependencies(compileData);
  }
  updateCSS(compileData) {
    this._css.set(compileData.normalizedFilename, compileData.compiled.css);
  }
  updateJS(compileData) {
    if (!compileData.ssr) {
      this._js.set(compileData.normalizedFilename, compileData.compiled.js);
    }
  }
  updateDependencies(compileData) {
    const id = compileData.normalizedFilename;
    const prevDependencies = this._dependencies.get(id) || [];
    const dependencies = compileData.dependencies;
    this._dependencies.set(id, dependencies);
    const removed = prevDependencies.filter((d) => !dependencies.includes(d));
    const added = dependencies.filter((d) => !prevDependencies.includes(d));
    added.forEach((d) => {
      if (!this._dependants.has(d)) {
        this._dependants.set(d, /* @__PURE__ */ new Set());
      }
      this._dependants.get(d).add(compileData.filename);
    });
    removed.forEach((d) => {
      this._dependants.get(d).delete(compileData.filename);
    });
  }
  remove(svelteRequest) {
    const id = svelteRequest.normalizedFilename;
    let removed = false;
    if (this._js.delete(id)) {
      removed = true;
    }
    if (this._css.delete(id)) {
      removed = true;
    }
    const dependencies = this._dependencies.get(id);
    if (dependencies) {
      removed = true;
      dependencies.forEach((d) => {
        const dependants = this._dependants.get(d);
        if (dependants && dependants.has(svelteRequest.filename)) {
          dependants.delete(svelteRequest.filename);
        }
      });
      this._dependencies.delete(id);
    }
    return removed;
  }
  getCSS(svelteRequest) {
    return this._css.get(svelteRequest.normalizedFilename);
  }
  getJS(svelteRequest) {
    if (!svelteRequest.ssr) {
      return this._js.get(svelteRequest.normalizedFilename);
    }
  }
  getDependants(path7) {
    const dependants = this._dependants.get(path7);
    return dependants ? [...dependants] : [];
  }
  getResolvedSvelteField(name, importer) {
    return this._resolvedSvelteFields.get(this._getResolvedSvelteFieldKey(name, importer));
  }
  setResolvedSvelteField(importee, importer = void 0, resolvedSvelte) {
    this._resolvedSvelteFields.set(this._getResolvedSvelteFieldKey(importee, importer), resolvedSvelte);
  }
  _getResolvedSvelteFieldKey(importee, importer) {
    return importer ? `${importer} > ${importee}` : importee;
  }
};

// src/utils/watch.ts
var import_fs4 = __toESM(require("fs"), 1);
var import_path4 = __toESM(require("path"), 1);
function setupWatchers(options, cache, requestParser) {
  const { server, configFile: svelteConfigFile } = options;
  if (!server) {
    return;
  }
  const { watcher, ws } = server;
  const { root, server: serverConfig } = server.config;
  const emitChangeEventOnDependants = (filename) => {
    const dependants = cache.getDependants(filename);
    dependants.forEach((dependant) => {
      if (import_fs4.default.existsSync(dependant)) {
        log.debug(`emitting virtual change event for "${dependant}" because depdendency "${filename}" changed`);
        watcher.emit("change", dependant);
      }
    });
  };
  const removeUnlinkedFromCache = (filename) => {
    const svelteRequest = requestParser(filename, false);
    if (svelteRequest) {
      const removedFromCache = cache.remove(svelteRequest);
      if (removedFromCache) {
        log.debug(`cleared VitePluginSvelteCache for deleted file ${filename}`);
      }
    }
  };
  const triggerViteRestart = (filename) => {
    if (serverConfig.middlewareMode) {
      const message = "Svelte config change detected, restart your dev process to apply the changes.";
      log.info(message, filename);
      ws.send({
        type: "error",
        err: { message, stack: "", plugin: "vite-plugin-svelte", id: filename }
      });
    } else {
      log.info(`svelte config changed: restarting vite server. - file: ${filename}`);
      server.restart();
    }
  };
  const possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => import_path4.default.join(root, cfg));
  const restartOnConfigAdd = (filename) => {
    if (possibleSvelteConfigs.includes(filename)) {
      triggerViteRestart(filename);
    }
  };
  const restartOnConfigChange = (filename) => {
    if (filename === svelteConfigFile) {
      triggerViteRestart(filename);
    }
  };
  const listenerCollection = {
    add: [],
    change: [emitChangeEventOnDependants],
    unlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]
  };
  if (svelteConfigFile) {
    listenerCollection.change.push(restartOnConfigChange);
    listenerCollection.unlink.push(restartOnConfigChange);
  } else {
    listenerCollection.add.push(restartOnConfigAdd);
  }
  Object.entries(listenerCollection).forEach(([evt, listeners]) => {
    if (listeners.length > 0) {
      watcher.on(evt, (filename) => listeners.forEach((listener) => listener(filename)));
    }
  });
}
function ensureWatchedFile(watcher, file, root) {
  if (file && !file.startsWith(root + "/") && !file.includes("\0") && import_fs4.default.existsSync(file)) {
    watcher.add(import_path4.default.resolve(file));
  }
}

// src/utils/resolve.ts
var import_path5 = __toESM(require("path"), 1);
var import_module4 = require("module");
function resolveViaPackageJsonSvelte(importee, importer, cache) {
  if (importer && isBareImport(importee) && !isNodeInternal(importee) && !is_common_without_svelte_field(importee)) {
    const cached = cache.getResolvedSvelteField(importee, importer);
    if (cached) {
      return cached;
    }
    const localRequire = (0, import_module4.createRequire)(importer);
    const pkgData = resolveDependencyData(importee, localRequire);
    if (pkgData) {
      const { pkg, dir } = pkgData;
      if (pkg.svelte) {
        const result = import_path5.default.resolve(dir, pkg.svelte);
        cache.setResolvedSvelteField(importee, importer, result);
        return result;
      }
    } else {
      throw new Error(`failed to resolve package.json of ${importee} imported by ${importer}`);
    }
  }
}
function isNodeInternal(importee) {
  return importee.startsWith("node:") || import_module4.builtinModules.includes(importee);
}
function isBareImport(importee) {
  if (!importee || importee[0] === "." || importee[0] === "\0" || importee.includes(":") || import_path5.default.isAbsolute(importee)) {
    return false;
  }
  const parts = importee.split("/");
  switch (parts.length) {
    case 1:
      return true;
    case 2:
      return parts[0].startsWith("@");
    default:
      return false;
  }
}

// src/utils/optimizer.ts
var import_fs5 = __toESM(require("fs"), 1);
var import_path6 = __toESM(require("path"), 1);
var import_vite4 = require("vite");
var PREBUNDLE_SENSITIVE_OPTIONS = [
  "compilerOptions",
  "configFile",
  "experimental",
  "extensions",
  "ignorePluginPreprocessors",
  "preprocess"
];
async function handleOptimizeDeps(options, viteConfig) {
  if (!options.experimental.prebundleSvelteLibraries || !viteConfig.cacheDir)
    return;
  const viteMetadataPath = import_path6.default.resolve(viteConfig.cacheDir, "_metadata.json");
  if (!import_fs5.default.existsSync(viteMetadataPath))
    return;
  const svelteMetadataPath = import_path6.default.resolve(viteConfig.cacheDir, "_svelte_metadata.json");
  const currentSvelteMetadata = JSON.stringify(generateSvelteMetadata(options), (_, value) => {
    return typeof value === "function" ? value.toString() : value;
  });
  if (import_fs5.default.existsSync(svelteMetadataPath)) {
    const existingSvelteMetadata = import_fs5.default.readFileSync(svelteMetadataPath, "utf8");
    if (existingSvelteMetadata === currentSvelteMetadata)
      return;
  }
  await (0, import_vite4.optimizeDeps)(viteConfig, true);
  import_fs5.default.writeFileSync(svelteMetadataPath, currentSvelteMetadata);
}
function generateSvelteMetadata(options) {
  const metadata = {};
  for (const key of PREBUNDLE_SENSITIVE_OPTIONS) {
    metadata[key] = options[key];
  }
  return metadata;
}

// src/index.ts
function svelte(inlineOptions) {
  if (process.env.DEBUG != null) {
    log.setLevel("debug");
  }
  validateInlineOptions(inlineOptions);
  const cache = new VitePluginSvelteCache();
  const pkg_resolve_errors = /* @__PURE__ */ new Set();
  let requestParser;
  let options;
  let viteConfig;
  let compileSvelte2;
  let resolvedSvelteSSR;
  return {
    name: "vite-plugin-svelte",
    enforce: "pre",
    async config(config, configEnv) {
      if (process.env.DEBUG) {
        log.setLevel("debug");
      } else if (config.logLevel) {
        log.setLevel(config.logLevel);
      }
      options = await preResolveOptions(inlineOptions, config, configEnv);
      const extraViteConfig = buildExtraViteConfig(options, config, configEnv);
      log.debug("additional vite config", extraViteConfig);
      return extraViteConfig;
    },
    async configResolved(config) {
      options = resolveOptions(options, config);
      patchResolvedViteConfig(config, options);
      requestParser = buildIdParser(options);
      compileSvelte2 = createCompileSvelte(options);
      viteConfig = config;
      log.debug("resolved options", options);
    },
    async buildStart() {
      await handleOptimizeDeps(options, viteConfig);
    },
    configureServer(server) {
      options.server = server;
      setupWatchers(options, cache, requestParser);
    },
    load(id, opts) {
      const ssr = opts === true || (opts == null ? void 0 : opts.ssr);
      const svelteRequest = requestParser(id, !!ssr);
      if (svelteRequest) {
        const { filename, query } = svelteRequest;
        if (query.svelte && query.type === "style") {
          const css = cache.getCSS(svelteRequest);
          if (css) {
            log.debug(`load returns css for ${filename}`);
            return css;
          }
        }
        if (viteConfig.assetsInclude(filename)) {
          log.debug(`load returns raw content for ${filename}`);
          return import_fs6.default.readFileSync(filename, "utf-8");
        }
      }
    },
    async resolveId(importee, importer, opts) {
      const ssr = !!(opts == null ? void 0 : opts.ssr);
      const svelteRequest = requestParser(importee, ssr);
      if (svelteRequest == null ? void 0 : svelteRequest.query.svelte) {
        if (svelteRequest.query.type === "style") {
          log.debug(`resolveId resolved virtual css module ${svelteRequest.cssId}`);
          return svelteRequest.cssId;
        }
        log.debug(`resolveId resolved ${importee}`);
        return importee;
      }
      if (ssr && importee === "svelte") {
        if (!resolvedSvelteSSR) {
          resolvedSvelteSSR = this.resolve("svelte/ssr", void 0, { skipSelf: true }).then((svelteSSR) => {
            log.debug("resolved svelte to svelte/ssr");
            return svelteSSR;
          }, (err) => {
            log.debug("failed to resolve svelte to svelte/ssr. Update svelte to a version that exports it", err);
            return null;
          });
        }
        return resolvedSvelteSSR;
      }
      try {
        const resolved = resolveViaPackageJsonSvelte(importee, importer, cache);
        if (resolved) {
          log.debug(`resolveId resolved ${resolved} via package.json svelte field of ${importee}`);
          return resolved;
        }
      } catch (err) {
        pkg_resolve_errors.add(importee);
      }
    },
    async transform(code, id, opts) {
      var _a;
      const ssr = !!(opts == null ? void 0 : opts.ssr);
      const svelteRequest = requestParser(id, ssr);
      if (!svelteRequest) {
        return;
      }
      const { filename, query } = svelteRequest;
      if (query.svelte) {
        if (query.type === "style") {
          const css = cache.getCSS(svelteRequest);
          if (css) {
            log.debug(`transform returns css for ${filename}`);
            return css;
          }
        }
        log.error("failed to transform tagged svelte request", svelteRequest);
        throw new Error(`failed to transform tagged svelte request for id ${id}`);
      }
      let compileData;
      try {
        compileData = await compileSvelte2(svelteRequest, code, options);
      } catch (e) {
        throw toRollupError(e, options);
      }
      logCompilerWarnings(compileData.compiled.warnings, options);
      cache.update(compileData);
      if (((_a = compileData.dependencies) == null ? void 0 : _a.length) && options.server) {
        compileData.dependencies.forEach((d) => {
          ensureWatchedFile(options.server.watcher, d, options.root);
        });
      }
      log.debug(`transform returns compiled js for ${filename}`);
      return compileData.compiled.js;
    },
    handleHotUpdate(ctx) {
      if (!options.hot || !options.emitCss) {
        return;
      }
      const svelteRequest = requestParser(ctx.file, false, ctx.timestamp);
      if (svelteRequest) {
        return handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options);
      }
    },
    buildEnd() {
      if (pkg_resolve_errors.size > 0) {
        log.warn(`vite-plugin-svelte was unable to find package.json of the following packages and wasn't able to resolve via their "svelte" field.
					If you had difficulties importing svelte components from a package, then please contact the author and ask them to export the package.json file.
					${Array.from(pkg_resolve_errors, (s) => `- ${s}`).join("\n")}`.replace(/\t/g, ""));
      }
    }
  };
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  svelte
});
//# sourceMappingURL=index.cjs.map